# [146. LRUç¼“å­˜æœºåˆ¶](https://leetcode-cn.com/problems/lru-cache/)

---

éš¾åº¦ `ä¸­ç­‰` | æ ‡ç­¾ `è®¾è®¡`  | ä¸ªäººæ ‡ç­¾ âŒğŸŒ€ãŠ™ï¸ | è·èµ `633`

---

## Description

<style>
section pre{
    background-color: #eee;
    border: 1px solid #ddd;
    padding:10px;
    border-radius: 5px;
}
</style>
<section>
<p>è¿ç”¨ä½ æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª&nbsp; <a href="https://baike.baidu.com/item/LRU">LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶</a>ã€‚å®ƒåº”è¯¥æ”¯æŒä»¥ä¸‹æ“ä½œï¼š è·å–æ•°æ® <code>get</code> å’Œ å†™å…¥æ•°æ® <code>put</code> ã€‚</p>
<p>è·å–æ•°æ® <code>get(key)</code> - å¦‚æœå…³é”®å­— (key) å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–å…³é”®å­—çš„å€¼ï¼ˆæ€»æ˜¯æ­£æ•°ï¼‰ï¼Œå¦åˆ™è¿”å› -1ã€‚<br>
å†™å…¥æ•°æ® <code>put(key, value)</code> - å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼›å¦‚æœå…³é”®å­—ä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥è¯¥ç»„ã€Œå…³é”®å­—/å€¼ã€ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚</p>
<p>&nbsp;</p>
<p><strong>è¿›é˜¶:</strong></p>
<p>ä½ æ˜¯å¦å¯ä»¥åœ¨&nbsp;<strong>O(1)</strong> æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸¤ç§æ“ä½œï¼Ÿ</p>
<p>&nbsp;</p>
<p><strong>ç¤ºä¾‹:</strong></p>
<pre>LRUCache cache = new LRUCache( 2 /* ç¼“å­˜å®¹é‡ */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // è¿”å›  1
cache.put(3, 3);    // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸ
cache.get(2);       // è¿”å› -1 (æœªæ‰¾åˆ°)
cache.put(4, 4);    // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸ
cache.get(1);       // è¿”å› -1 (æœªæ‰¾åˆ°)
cache.get(3);       // è¿”å›  3
cache.get(4);       // è¿”å›  4
</pre>
</section>

## My Solution

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.cache={}
        self.head=BiLink()
        self.tail=self.head
        self.num=0
        self.capacity=capacity

    def get(self, key: int) -> int:
        if key not in self.cache: return -1
        node=self.cache[key]
        if node.pre!=self.head:self.move2h(node)
        return node.val


    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node=self.cache[key]
            node.val=value
            self.move2h(node)
        else:
            if self.num==self.capacity:
                del self.cache[self.tail.key]
                self.tail=self.tail.pre
                self.tail.nxt=None
                self.num-=1
            self.num+=1
            self.head.key=key
            self.head.val=value
            node=self.head
            self.head=BiLink()
            self.head.nxt=node
            node.pre=self.head
            self.cache[key]=node

    def move2h(self, node):
        if node.pre==self.head: return
        if self.tail==node:self.tail=self.tail.pre
        node.pre.nxt=node.nxt
        if node.nxt: node.nxt.pre=node.pre
        node.pre,node.nxt=self.head,self.head.nxt
        self.head.nxt.pre=node
        self.head.nxt=node

class BiLink:
    def __init__(self, key=0,val=0):
        self.key=key
        self.val=val
        self.pre=None
        self.nxt=None
```

